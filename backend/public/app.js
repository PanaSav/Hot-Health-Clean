/* global MediaRecorder */
document.addEventListener('DOMContentLoaded', () => {
  const $ = (s)=>document.querySelector(s);

  const btnRec      = $('#btnRec');
  const meta        = $('#recMeta');
  const out         = $('#result');
  const errBox      = $('#error');
  const actions     = $('#actions');
  const openLink    = $('#openLink');
  const gmailLink   = $('#gmailLink');
  const outlookLink = $('#outlookLink');
  const copyBtn     = $('#copyBtn');
  const printBtn    = $('#printBtn');

  let mediaRecorder, chunks = [], autoTimer = null;

  const safeVal = (id) => {
    const el = document.getElementById(id);
    if (!el) return '';
    return (el.value || '').trim();
  };

  function setError(msg){ if (errBox) errBox.textContent = msg || ''; }
  function setMeta(msg){  if (meta)   meta.textContent   = msg || ''; }

  function gatherForm() {
    // All IDs must exist in index.html; safeVal prevents crashes if not.
    return {
      name:       safeVal('pName'),
      email:      safeVal('pEmail'),
      emer_name:  safeVal('eName'),
      emer_phone: safeVal('ePhone'),
      emer_email: safeVal('eEmail'),
      blood_type: safeVal('blood'),
      lang:       safeVal('lang'),

      doc_name:   safeVal('docName'),
      doc_phone:  safeVal('docPhone'),
      doc_fax:    safeVal('docFax'),
      doc_email:  safeVal('docEmail'),
      doc_addr:   safeVal('docAddr'),

      ph_name:    safeVal('phName'),
      ph_phone:   safeVal('phPhone'),
      ph_fax:     safeVal('phFax'),
      ph_email:   safeVal('phEmail'),
      ph_addr:    safeVal('phAddr'),

      bp_text:         safeVal('bpText'),
      meds_text:       safeVal('medsText'),
      allergies_text:  safeVal('allergiesText'),
      weight_text:     safeVal('weightText'),
      conditions_text: safeVal('conditionsText'),
      general_text:    safeVal('generalText'),
    };
  }

  async function uploadBlob(blob) {
    const fd = new FormData();
    fd.append('audio', blob, 'recording.webm');
    const data = gatherForm();
    for (const [k,v] of Object.entries(data)) fd.append(k, v);
    const r = await fetch('/upload', { method:'POST', body: fd });
    if (!r.ok) {
      const text = await r.text().catch(()=> '');
      throw new Error(`Upload failed (${r.status}): ${text || 'Server error'}`);
    }
    return r.json();
  }

  function setActions(url) {
    if (!actions) return;
    actions.classList.remove('hidden');
    if (openLink)   openLink.href = url;

    const subject = encodeURIComponent('Hot Health — Shareable Report');
    const body    = encodeURIComponent(`Here is the report link:\n\n${url}\n\n(Generated by Hot Health)`);
    if (gmailLink)   gmailLink.href   = `https://mail.google.com/mail/?view=cm&fs=1&su=${subject}&body=${body}`;
    if (outlookLink) outlookLink.href = `https://outlook.live.com/owa/?path=/mail/action/compose&subject=${subject}&body=${body}`;

    if (copyBtn) copyBtn.onclick = async () => {
      try { await navigator.clipboard.writeText(url); copyBtn.textContent='Copied!'; setTimeout(()=>copyBtn.textContent='Copy Link',1000); }
      catch { alert('Copy failed'); }
    };
    if (printBtn) printBtn.onclick = () => window.open(url, '_blank', 'noopener');
  }

  async function startRec() {
    setError('');
    setMeta('');
    chunks = [];
    let stream;
    try {
      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch {
      setError('Microphone blocked. Allow mic permission and try again.');
      return;
    }
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
    mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
    mediaRecorder.onstop = async () => {
      try {
        clearTimeout(autoTimer); autoTimer = null;
        const blob = new Blob(chunks, { type: 'audio/webm' });
        setMeta(`Recorded ${(blob.size/1024).toFixed(1)} KB`);
        const json = await uploadBlob(blob);
        if (!json.ok) throw new Error(json.error || 'Server error');
        if (out) out.innerHTML = `✅ Report created.`;
        setActions(json.url);
      } catch (e) {
        setError(e.message || String(e));
      } finally {
        mediaRecorder.stream.getTracks().forEach(t=>t.stop());
        if (btnRec) {
          btnRec.textContent = '● Record';
          btnRec.classList.add('primary');
        }
      }
    };
    mediaRecorder.start();
    if (btnRec) {
      btnRec.textContent = '■ Stop';
      btnRec.classList.remove('primary');
    }
    setMeta('Recording… tap Stop when done.');
    // 30s auto-stop
    autoTimer = setTimeout(()=>{ if (mediaRecorder && mediaRecorder.state==='recording') mediaRecorder.stop(); }, 30000);
  }

  function stopRec() {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
    }
  }

  if (btnRec) {
    btnRec.addEventListener('click', () => {
      if (!mediaRecorder || mediaRecorder.state === 'inactive') startRec();
      else stopRec();
    });
  }

  // Dictation mics for inputs (Web Speech API)
  (function initDictation() {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    document.querySelectorAll('.mic-btn').forEach(btn => {
      const targetId = btn.getAttribute('data-target');
      const el = document.getElementById(targetId);
      if (!SR || !el) { btn.disabled = true; btn.title = 'Voice input not supported by this browser.'; return; }

      btn.addEventListener('click', () => {
        const rec = new SR();
        rec.lang = 'en-US';
        rec.interimResults = false;
        rec.maxAlternatives = 1;

        const orig = btn.textContent;
        btn.textContent = '⏺';
        btn.disabled = true;

        const originalBg = el.style.backgroundColor;
        el.style.backgroundColor = '#fff7cc';

        rec.onresult = (e) => {
          const text = (e.results[0] && e.results[0][0] && e.results[0][0].transcript) || '';
          if (el.tagName === 'SELECT') {
            const opt = [...el.options].find(o => o.textContent.toLowerCase().includes(text.toLowerCase()));
            if (opt) el.value = opt.value;
          } else {
            let cleaned = text
              .replace(/\s+at\s+symbol\s+/ig, '@')
              .replace(/\s+at\s+/ig, '@')
              .replace(/\s+dot\s+/ig, '.')
              .replace(/\s+dash\s+/ig, '-')
              .replace(/\s+underscore\s+/ig, '_')
              .replace(/\s+plus\s+/ig, '+');
            if ('value' in el) {
              el.value = (el.value ? (el.value + ' ' + cleaned) : cleaned).trim();
            }
          }
        };
        rec.onend = () => {
          btn.textContent = orig;
          btn.disabled = false;
          el.style.backgroundColor = originalBg;
        };
        rec.onerror = () => {
          btn.textContent = orig;
          btn.disabled = false;
          el.style.backgroundColor = originalBg;
        };

        try { rec.start(); } catch {
          btn.textContent = orig;
          btn.disabled = false;
          el.style.backgroundColor = originalBg;
        }
      });
    });
  })();
});
